
# AFL Basics

AFL (array functional language) is SciDB's native query language. This document
gives a short introduction into the most important operations. For details on individual operations, please also
check the official [manual](https://paradigm4.atlassian.net/wiki/spaces/ESD/pages/19955833/SciDB+Operators#SciDBOperators-IndividualOperatorDocumentation).

The aim of this document is to demonstrate what kind of operations can be performed with
SciDB's built in functionality and where their limitations are. Not all available operators
are discused here. For a complete list, please again check the official [manual](https://paradigm4.atlassian.net/wiki/spaces/ESD/pages/19955833/SciDB+Operators#SciDBOperators-IndividualOperatorDocumentation).


## Example dataset
The explanations below all refer to a three-dimensional
example array representing a Sentinel 2 image time series (see below), 
which has 4 attributes (bands visible and near infrared bands at 10m spatial resolution) 
and 10980 x 10980 pixels from 26 images.
![](s2animation.gif)




## SciDB Operator Basics
The array schema can be queried with the `show()` operator:

```
%AFL show(S2_OKAVANGO_S)
> S2_OKAVANGO_S<band1:uint16 NOT NULL,band2:uint16 NOT NULL,band3:uint16 NOT NULL,band4:uint16 NOT NULL> [y=0:10980,2048,0,x=0:10980,2048,0,t=0:*,1,0]
```

Operators in general take one or more input arrays and maybe other parameters and produce a single output array. Queries can be nested as in the following typical expression.

The query 
```
%AFL aggregate(filter(apply(S2_OKAVANGO_S, ndvi, (band4 - band3) / (band4 + band3)), ndvi > 0.2), count(*))
```
counts how many Sentinel 2 pixels have an NDVI value greater than 0.2.

Besides `show()`, a further simple operators that help with array metadata are:

* `list()` lists all available arrays in the database,
* `dimensions(S2_OKAVANGO_S)` returns details about the array dimensions including the chunk sizes, and
* `attributes(S2_OKAVANGO_S)` returns details about the array attributes including their data types.

## CRUD operators

Arrays can be created from scratch by specifying a schema without any data, loaded from files, 
or built by expressions.

* `CREATE ARRAY %NAME% %SCHEMA%` creates an empty array with a given schema
* `load` and `input` read binary or text-formatted (e.g., CSV) files as arrays, and 
* `build` creates one-attribute arrays with data being generated by a simple expression.

For example, `build(<val:double>[y=0:9,10,0, x=0:9,10,0], random() / 2147483647)` creates a two-dimensional array with 10x10 cells where attribute values are random numbers.

The result array of the previous query exists only temporarily (if at all), to persist
the it on disk one needs to apply the `store()` operator on the result and specify a name.

Persistent arrays can be exported as files (binary or text-formatted) with `save()` and can be deleted
with `remove()`. The community edition of SciDB does **not** come with user management. Everyone is allowed to
delete all arrays. 

The `insert()` operator finally inserts nonempty cells of a source array to a target array where the array schemas must be compatible.

TODO: merge operator here?


## Subsetting

* subarray
* between
* filter
* project
* slice

## Simple arithmetic / logical Expressions
* apply

`apply(S2_OKAVANGO_S, ndvi, (band4-band3)/(band4+band3))`

## Aggregations

by dimensions...

* aggregate

`aggregate(S2_OKAVANGO_S, avg(band1), count(*), min(band1), max(band1) , x, y)`

* window

`window(S2_OKAVANGO_S, 1, 1, 1, 1, avg(band1), avg(band2), avg(band3), avg(band4))`





##

* repart
* reshape
* redimension


## Joins

* merge
* join
* cross_join


## Linear algebra

* gemm
* gesvd


